{
  "_args": [
    [
      {
        "raw": "yauzl@https://registry.npmjs.org/yauzl/-/yauzl-2.4.1.tgz",
        "scope": null,
        "escapedName": "yauzl",
        "name": "yauzl",
        "rawSpec": "https://registry.npmjs.org/yauzl/-/yauzl-2.4.1.tgz",
        "spec": "https://registry.npmjs.org/yauzl/-/yauzl-2.4.1.tgz",
        "type": "remote"
      },
      "/Users/edgar/node_modules/dr-svg-sprites"
    ]
  ],
  "_from": "https://registry.npmjs.org/yauzl/-/yauzl-2.4.1.tgz",
  "_id": "yauzl@2.4.1",
  "_inCache": true,
  "_location": "/dr-svg-sprites/yauzl",
  "_phantomChildren": {},
  "_requested": {
    "raw": "yauzl@https://registry.npmjs.org/yauzl/-/yauzl-2.4.1.tgz",
    "scope": null,
    "escapedName": "yauzl",
    "name": "yauzl",
    "rawSpec": "https://registry.npmjs.org/yauzl/-/yauzl-2.4.1.tgz",
    "spec": "https://registry.npmjs.org/yauzl/-/yauzl-2.4.1.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/dr-svg-sprites",
    "/dr-svg-sprites/extract-zip"
  ],
  "_resolved": "https://registry.npmjs.org/yauzl/-/yauzl-2.4.1.tgz",
  "_shasum": "9528f442dab1b2284e58b4379bb194e22e0c4005",
  "_shrinkwrap": null,
  "_spec": "yauzl@https://registry.npmjs.org/yauzl/-/yauzl-2.4.1.tgz",
  "_where": "/Users/edgar/node_modules/dr-svg-sprites",
  "author": {
    "name": "Josh Wolfe",
    "email": "thejoshwolfe@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/thejoshwolfe/yauzl/issues"
  },
  "dependencies": {
    "fd-slicer": "~1.0.1"
  },
  "description": "yet another unzip library for node",
  "devDependencies": {
    "bl": "~1.0.0",
    "istanbul": "~0.3.4",
    "pend": "~1.2.0"
  },
  "homepage": "https://github.com/thejoshwolfe/yauzl",
  "keywords": [
    "unzip",
    "zip",
    "stream",
    "archive",
    "file"
  ],
  "license": "MIT",
  "main": "index.js",
  "name": "yauzl",
  "optionalDependencies": {},
  "readme": "# yauzl\n\n[![Build Status](https://travis-ci.org/thejoshwolfe/yauzl.svg?branch=master)](https://travis-ci.org/thejoshwolfe/yauzl)\n[![Coverage Status](https://img.shields.io/coveralls/thejoshwolfe/yauzl.svg)](https://coveralls.io/r/thejoshwolfe/yauzl)\n\nyet another unzip library for node. For zipping, see\n[yazl](https://github.com/thejoshwolfe/yazl).\n\nDesign principles:\n\n * Follow the spec.\n   Don't scan for local file headers.\n   Read the central directory for file metadata.\n   (see [No Streaming Unzip API](#no-streaming-unzip-api)).\n * Don't block the JavaScript thread.\n   Use and provide async APIs.\n * Keep memory usage under control.\n   Don't attempt to buffer entire files in RAM at once.\n * Never crash (if used properly).\n   Don't let malformed zip files bring down client applications who are trying to catch errors.\n * Catch unsafe filenames entries.\n   A zip file entry throws an error if its file name starts with `\"/\"` or `/[A-Za-z]:\\//`\n   or if it contains `\"..\"` path segments or `\"\\\\\"` (per the spec).\n\n## Usage\n\n```js\nvar yauzl = require(\"yauzl\");\nvar fs = require(\"fs\");\nvar path = require(\"path\");\nvar mkdirp = require(\"mkdirp\"); // or similar\n\nyauzl.open(\"path/to/file.zip\", {lazyEntries: true}, function(err, zipfile) {\n  if (err) throw err;\n  zipfile.readEntry();\n  zipfile.on(\"entry\", function(entry) {\n    if (/\\/$/.test(entry.fileName)) {\n      // directory file names end with '/'\n      mkdirp(entry.fileName, function(err) {\n        if (err) throw err;\n        zipfile.readEntry();\n      });\n    } else {\n      // file entry\n      zipfile.openReadStream(entry, function(err, readStream) {\n        if (err) throw err;\n        // ensure parent directory exists\n        mkdirp(path.dirname(entry.fileName), function(err) {\n          if (err) throw err;\n          readStream.pipe(fs.createWriteStream(entry.fileName));\n          readStream.on(\"end\", function() {\n            zipfile.readEntry();\n          });\n        });\n      });\n    }\n  });\n});\n```\n\n## API\n\nThe default for every optional `callback` parameter is:\n\n```js\nfunction defaultCallback(err) {\n  if (err) throw err;\n}\n```\n\n### open(path, [options], [callback])\n\nCalls `fs.open(path, \"r\")` and gives the `fd`, `options`, and `callback` to `fromFd()` below.\n\n`options` may be omitted or `null`. The defaults are `{autoClose: true, lazyEntries: false}`.\n\n`autoClose` is effectively equivalent to:\n\n```js\nzipfile.once(\"end\", function() {\n  zipfile.close();\n});\n```\n\n`lazyEntries` indicates that entries should be read only when `readEntry()` is called.\nIf `lazyEntries` is `false`, `entry` events will be emitted as fast as possible to allow `pipe()`ing\nfile data from all entries in parallel.\nThis is not recommended, as it can lead to out of control memory usage for zip files with many entries.\nSee [issue #22](https://github.com/thejoshwolfe/yauzl/issues/22).\nIf `lazyEntries` is `true`, an `entry` or `end` event will be emitted in response to each call to `readEntry()`.\nThis allows processing of one entry at a time, and will keep memory usage under control for zip files with many entries.\n\n### fromFd(fd, [options], [callback])\n\nReads from the fd, which is presumed to be an open .zip file.\nNote that random access is required by the zip file specification,\nso the fd cannot be an open socket or any other fd that does not support random access.\n\nThe `callback` is given the arguments `(err, zipfile)`.\nAn `err` is provided if the End of Central Directory Record Signature cannot be found in the file,\nwhich indicates that the fd is not a zip file.\n`zipfile` is an instance of `ZipFile`.\n\n`options` may be omitted or `null`. The defaults are `{autoClose: false, lazyEntries: false}`.\nSee `open()` for the meaning of the options.\n\n### fromBuffer(buffer, [options], [callback])\n\nLike `fromFd()`, but reads from a RAM buffer instead of an open file.\n`buffer` is a `Buffer`.\n`callback` is effectively passed directly to `fromFd()`.\n\nIf a `ZipFile` is acquired from this method,\nit will never emit the `close` event,\nand calling `close()` is not necessary.\n\n`options` may be omitted or `null`. The defaults are `{lazyEntries: false}`.\nSee `open()` for the meaning of the options.\nThe `autoClose` option is ignored for this method.\n\n### fromRandomAccessReader(reader, totalSize, [options], [callback])\n\nThis method of creating a zip file allows clients to implement their own back-end file system.\nFor example, a client might translate read calls into network requests.\n\nThe `reader` parameter must be of a type that is a subclass of\n[RandomAccessReader](#class-randomaccessreader) that implements the required methods.\nThe `totalSize` is a Number and indicates the total file size of the zip file.\n\n`options` may be omitted or `null`. The defaults are `{autoClose: true, lazyEntries: false}`.\nSee `open()` for the meaning of the options.\n\n### dosDateTimeToDate(date, time)\n\nConverts MS-DOS `date` and `time` data into a JavaScript `Date` object.\nEach parameter is a `Number` treated as an unsigned 16-bit integer.\nNote that this format does not support timezones,\nso the returned object will use the local timezone.\n\n### Class: ZipFile\n\nThe constructor for the class is not part of the public API.\nUse `open()`, `fromFd()`, `fromBuffer()`, or `fromRandomAccessReader()` instead.\n\n#### Event: \"entry\"\n\nCallback gets `(entry)`, which is an `Entry`.\nSee `open()` and `readEntry()` for when this event is emitted.\n\n#### Event: \"end\"\n\nEmitted after the last `entry` event has been emitted.\nSee `open()` and `readEntry()` for more info on when this event is emitted.\n\n#### Event: \"close\"\n\nEmitted after the fd is actually closed.\nThis is after calling `close()` (or after the `end` event when `autoClose` is `true`),\nand after all stream pipelines created from `openReadStream()` have finished reading data from the fd.\n\nIf this `ZipFile` was acquired from `fromRandomAccessReader()`,\nthe \"fd\" in the previous paragraph refers to the `RandomAccessReader` implemented by the client.\n\nIf this `ZipFile` was acquired from `fromBuffer()`, this event is never emitted.\n\n#### Event: \"error\"\n\nEmitted in the case of errors with reading the zip file.\n(Note that other errors can be emitted from the streams created from `openReadStream()` as well.)\nAfter this event has been emitted, no further `entry`, `end`, or `error` events will be emitted,\nbut the `close` event may still be emitted.\n\n#### readEntry()\n\nCauses this `ZipFile` to emit an `entry` or `end` event (or an `error` event).\nThis method must only be called when this `ZipFile` was created with the `lazyEntries` option set to `true` (see `open()`).\nWhen this `ZipFile` was created with the `lazyEntries` option set to `true`,\n`entry` and `end` events are only ever emitted in response to this method call.\n\nThe event that is emitted in response to this method will not be emitted until after this method has returned,\nso it is safe to call this method before attaching event listeners.\n\nAfter calling this method, calling this method again before the response event has been emitted will cause undefined behavior.\nCalling this method after the `end` event has been emitted will cause undefined behavior.\nCalling this method after calling `close()` will cause undefined behavior.\n\n#### openReadStream(entry, callback)\n\n`entry` must be an `Entry` object from this `ZipFile`.\n`callback` gets `(err, readStream)`, where `readStream` is a `Readable Stream`.\nIf the entry is compressed (with a supported compression method),\nthe read stream provides the decompressed data.\nIf this zipfile is already closed (see `close()`), the `callback` will receive an `err`.\n\nIt's possible for the `readStream` it to emit errors for several reasons.\nFor example, if zlib cannot decompress the data, the zlib error will be emitted from the `readStream`.\nTwo more error cases are if the decompressed data has too many or too few actual bytes\ncompared to the reported byte count from the entry's `uncompressedSize` field.\nyauzl notices this false information and emits an error from the `readStream`\nafter some number of bytes have already been piped through the stream.\n\nBecause of this check, clients can always trust the `uncompressedSize` field in `Entry` objects.\nGuarding against [zip bomb](http://en.wikipedia.org/wiki/Zip_bomb) attacks can be accomplished by\ndoing some heuristic checks on the size metadata and then watching out for the above errors.\nSuch heuristics are outside the scope of this library,\nbut enforcing the `uncompressedSize` is implemented here as a security feature.\n\nIt is possible to destroy the `readStream` before it has piped all of its data.\nTo do this, call `readStream.destroy()`.\nYou must `unpipe()` the `readStream` from any destination before calling `readStream.destroy()`.\nIf this zipfile was created using `fromRandomAccessReader()`, the `RandomAccessReader` implementation\nmust provide readable streams that implement a `.destroy()` method (see `randomAccessReader._readStreamForRange()`)\nin order for calls to `readStream.destroy()` to work in this context.\n\n#### close()\n\nCauses all future calls to `openReadStream()` to fail,\nand closes the fd after all streams created by `openReadStream()` have emitted their `end` events.\n\nIf the `autoClose` option is set to `true` (see `open()`),\nthis function will be called automatically effectively in response to this object's `end` event.\n\nIf the `lazyEntries` option is set to `false` (see `open()`) and this object's `end` event has not been emitted yet,\nthis function causes undefined behavior.\nIf the `lazyEntries` option is set to `true`,\nyou can call this function instead of calling `readEntry()` to abort reading the entries of a zipfile.\n\nIt is safe to call this function multiple times; after the first call, successive calls have no effect.\nThis includes situations where the `autoClose` option effectively calls this function for you.\n\n#### isOpen\n\n`Boolean`. `true` until `close()` is called; then it's `false`.\n\n#### entryCount\n\n`Number`. Total number of central directory records.\n\n#### comment\n\n`String`. Always decoded with `CP437` per the spec.\n\n### Class: Entry\n\nObjects of this class represent Central Directory Records.\nRefer to the zipfile specification for more details about these fields.\n\nThese fields are of type `Number`:\n\n * `versionMadeBy`\n * `versionNeededToExtract`\n * `generalPurposeBitFlag`\n * `compressionMethod`\n * `lastModFileTime` (MS-DOS format, see `getLastModDateTime`)\n * `lastModFileDate` (MS-DOS format, see `getLastModDateTime`)\n * `crc32`\n * `compressedSize`\n * `uncompressedSize`\n * `fileNameLength` (bytes)\n * `extraFieldLength` (bytes)\n * `fileCommentLength` (bytes)\n * `internalFileAttributes`\n * `externalFileAttributes`\n * `relativeOffsetOfLocalHeader`\n\n#### fileName\n\n`String`.\nFollowing the spec, the bytes for the file name are decoded with\n`UTF-8` if `generalPurposeBitFlag & 0x800`, otherwise with `CP437`.\n\nIf `fileName` would contain unsafe characters, such as an absolute path or\na relative directory, yauzl emits an error instead of an entry.\n\n#### extraFields\n\n`Array` with each entry in the form `{id: id, data: data}`,\nwhere `id` is a `Number` and `data` is a `Buffer`.\nThis library looks for and reads the ZIP64 Extended Information Extra Field (0x0001)\nin order to support ZIP64 format zip files.\nNone of the other fields are considered significant by this library.\n\n#### comment\n\n`String` decoded with the same charset as used for `fileName`.\n\n#### getLastModDate()\n\nEffectively implemented as:\n\n```js\nreturn dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);\n```\n\n### Class: RandomAccessReader\n\nThis class is meant to be subclassed by clients and instantiated for the `fromRandomAccessReader()` function.\n\nAn example implementation can be found in `test/test.js`.\n\n#### randomAccessReader._readStreamForRange(start, end)\n\nSubclasses *must* implement this method.\n\n`start` and `end` are Numbers and indicate byte offsets from the start of the file.\n`end` is exclusive, so `_readStreamForRange(0x1000, 0x2000)` would indicate to read `0x1000` bytes.\n`end - start` will always be at least `1`.\n\nThis method should return a readable stream which will be `pipe()`ed into another stream.\nIt is expected that the readable stream will provide data in several chunks if necessary.\nIf the readable stream provides too many or too few bytes, an error will be emitted.\nAny errors emitted on the readable stream will be handled and re-emitted on the client-visible stream\n(returned from `zipfile.openReadStream()`) or provided as the `err` argument to the appropriate callback\n(for example, for `fromRandomAccessReader()`).\n\nThe returned stream *must* implement a method `.destroy()`\nif you call `readStream.destroy()` on streams you get from `openReadStream()`.\nIf you never call `readStream.destroy()`, then streams returned from this method do not need to implement a method `.destroy()`.\n`.destroy()` should abort any streaming that is in progress and clean up any associated resources.\n`.destroy()` will only be called after the stream has been `unpipe()`d from its destination.\n\nNote that the stream returned from this method might not be the same object that is provided by `openReadStream()`.\nThe stream returned from this method might be `pipe()`d through one or more filter streams (for example, a zlib inflate stream).\n\n#### randomAccessReader.read(buffer, offset, length, position, callback)\n\nSubclasses may implement this method.\nThe default implementation uses `createReadStream()` to fill the `buffer`.\n\nThis method should behave like `fs.read()`.\n\n#### randomAccessReader.close(callback)\n\nSubclasses may implement this method.\nThe default implementation is effectively `setImmediate(callback);`.\n\n`callback` takes parameters `(err)`.\n\nThis method is called once the all streams returned from `_readStreamForRange()` have ended,\nand no more `_readStreamForRange()` or `read()` requests will be issued to this object.\n\n## How to Avoid Crashing\n\nWhen a malformed zipfile is encountered, the default behavior is to crash (throw an exception).\nIf you want to handle errors more gracefully than this,\nbe sure to do the following:\n\n * Provide `callback` parameters where they are allowed, and check the `err` parameter.\n * Attach a listener for the `error` event on any `ZipFile` object you get from `open()`, `fromFd()`, `fromBuffer()`, or `fromRandomAccessReader()`.\n * Attach a listener for the `error` event on any stream you get from `openReadStream()`.\n\n## Limitations\n\n### No Streaming Unzip API\n\nDue to the design of the .zip file format, it's impossible to interpret a .zip file from start to finish\n(such as from a readable stream) without sacrificing correctness.\nThe Central Directory, which is the authority on the contents of the .zip file, is at the end of a .zip file, not the beginning.\nA streaming API would need to either buffer the entire .zip file to get to the Central Directory before interpreting anything\n(defeating the purpose of a streaming interface), or rely on the Local File Headers which are interspersed through the .zip file.\nHowever, the Local File Headers are explicitly denounced in the spec as being unreliable copies of the Central Directory,\nso trusting them would be a violation of the spec.\n\nAny library that offers a streaming unzip API must make one of the above two compromises,\nwhich makes the library either dishonest or nonconformant (usually the latter).\nThis library insists on correctness and adherence to the spec, and so does not offer a streaming API.\n\n### Limitted ZIP64 Support\n\nFor ZIP64, only zip files smaller than `8PiB` are supported,\nnot the full `16EiB` range that a 64-bit integer should be able to index.\nThis is due to the JavaScript Number type being an IEEE 754 double precision float.\n\nThe Node.js `fs` module probably has this same limitation.\n\n### ZIP64 Extensible Data Sector Is Ignored\n\nThe spec does not allow zip file creators to put arbitrary data here,\nbut rather reserves its use for PKWARE and mentions something about Z390.\nThis doesn't seem useful to expose in this library, so it is ignored.\n\n### No Multi-Disk Archive Support\n\nThis library does not support multi-disk zip files.\nThe multi-disk fields in the zipfile spec were intended for a zip file to span multiple floppy disks,\nwhich probably never happens now.\nIf the \"number of this disk\" field in the End of Central Directory Record is not `0`,\nthe `open()`, `fromFd()`, `fromBuffer()`, or `fromRandomAccessReader()` `callback` will receive an `err`.\nBy extension the following zip file fields are ignored by this library and not provided to clients:\n\n * Disk where central directory starts\n * Number of central directory records on this disk\n * Disk number where file starts\n\n### No Encryption Support\n\nCurrently, the presence of encryption is not even checked,\nand encrypted zip files will cause undefined behavior.\n\n### Local File Headers Are Ignored\n\nMany unzip libraries mistakenly read the Local File Header data in zip files.\nThis data is officially defined to be redundant with the Central Directory information,\nand is not to be trusted.\nAside from checking the signature, yauzl ignores the content of the Local File Header.\n\n### No CRC-32 Checking\n\nThis library provides the `crc32` field of `Entry` objects read from the Central Directory.\nHowever, this field is not used for anything in this library.\n\n### versionNeededToExtract Is Ignored\n\nThe field `versionNeededToExtract` is ignored,\nbecause this library doesn't support the complete zip file spec at any version,\n\n### No Support For Obscure Compression Methods\n\nRegarding the `compressionMethod` field of `Entry` objects,\nonly method `0` (stored with no compression)\nand method `8` (deflated) are supported.\nAny of the other 15 official methods will cause the `openReadStream()` `callback` to receive an `err`.\n\n### Data Descriptors Are Ignored\n\nThere may or may not be Data Descriptor sections in a zip file.\nThis library provides no support for finding or interpreting them.\n\n### Archive Extra Data Record Is Ignored\n\nThere may or may not be an Archive Extra Data Record section in a zip file.\nThis library provides no support for finding or interpreting it.\n\n### No Language Encoding Flag Support\n\nZip files officially support charset encodings other than CP437 and UTF-8,\nbut the zip file spec does not specify how it works.\nThis library makes no attempt to interpret the Language Encoding Flag.\n\n## Change History\n\n * 2.4.1\n   * Fix error handling.\n * 2.4.0\n   * Add ZIP64 support. [issue #6](https://github.com/thejoshwolfe/yazl/issues/6)\n   * Add `lazyEntries` option. [issue #22](https://github.com/thejoshwolfe/yazl/issues/22)\n   * Add `readStream.destroy()` method. [issue #26](https://github.com/thejoshwolfe/yazl/issues/26)\n   * Add `fromRandomAccessReader()`. [issue #14](https://github.com/thejoshwolfe/yazl/issues/14)\n   * Add `examples/unzip.js`.\n * 2.3.1\n   * Documentation updates.\n * 2.3.0\n   * Check that `uncompressedSize` is correct, or else emit an error. [issue #13](https://github.com/thejoshwolfe/yazl/issues/13)\n * 2.2.1\n   * Update dependencies.\n * 2.2.0\n   * Update dependencies.\n * 2.1.0\n   * Remove dependency on `iconv`.\n * 2.0.3\n   * Fix crash when trying to read a 0-byte file.\n * 2.0.2\n   * Fix event behavior after errors.\n * 2.0.1\n   * Fix bug with using `iconv`.\n * 2.0.0\n   * Initial release.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/thejoshwolfe/yauzl.git"
  },
  "scripts": {
    "test": "node test/test.js",
    "test-cov": "istanbul cover test/test.js",
    "test-travis": "istanbul cover --report lcovonly test/test.js"
  },
  "version": "2.4.1"
}
