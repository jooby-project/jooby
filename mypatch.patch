package io.jooby.internal.pac4j;

import io.jooby.Session;
import io.jooby.SneakyThrows;
import io.jooby.Value;
import io.jooby.pac4j.Pac4jContext;
import org.pac4j.core.context.session.SessionStore;

import org.pac4j.core.exception.http.UnauthorizedAction;
import org.pac4j.core.exception.http.WithContentAction;
import org.pac4j.core.exception.http.WithLocationAction;
import org.pac4j.core.util.JavaSerializationHelper;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.Base64;
import java.io.*;
import java.util.Optional;

import static io.jooby.StatusCode.BAD_REQUEST_CODE;

public class SessionStoreImpl
    implements org.pac4j.core.context.session.SessionStore<Pac4jContext> {

  private static final String PAC4J = "p4j~";

  private static final String BIN = "b64~";

  private Session getSession(Pac4jContext context) {
    return context.getContext().session();
    return session(context.getContext().session());
  }

  private Session session(Session session) {
    if (session instanceof Pac4jSession) {
      return ((Pac4jSession) session).getSession();
    }
    return session;
  }

  private Optional<Session> getSessionOrEmpty(Pac4jContext context) {
    return Optional.ofNullable(context.getContext().sessionOrNull());
    return Optional.ofNullable(session(context.getContext().sessionOrNull()));
  }

  @Override public String getOrCreateSessionId(Pac4jContext context) {

  }

  @Override public boolean renewSession(Pac4jContext context) {
    //getSessionOrEmpty(context).ifPresent(session -> session.renewId());
    getSessionOrEmpty(context).ifPresent(Session::renewId);
    return true;
  }


      return Optional.empty();
    }
    String value = node.value();
    if (value.startsWith(BIN)) {
      try {
        byte[] bytes = Base64.getDecoder().decode(value.substring(BIN.length()));
        return Optional.of(new ObjectInputStream(new ByteArrayInputStream(bytes)).readObject());
      } catch (Exception x) {
        throw SneakyThrows.propagate(x);
      }
    } else if (value.startsWith(PAC4J)) {
      return Optional.of(strToAction(value.substring(PAC4J.length())));
    if (value.startsWith(Pac4jSession.BIN)) {
       JavaSerializationHelper helper = new JavaSerializationHelper();
       return Optional.of(helper.deserializeFromBase64(value.substring(Pac4jSession.BIN.length())));
    } else if (value.startsWith(Pac4jSession.PAC4J)) {
      return Optional.of(strToAction(value.substring(Pac4jSession.PAC4J.length())));
    }
    return Optional.of(value);
  }

      return value.toString();
    } else if (value instanceof HttpAction) {
      return actionToStr((HttpAction) value);
    }
    try {
      ByteArrayOutputStream bytes = new ByteArrayOutputStream();
      ObjectOutputStream stream = new ObjectOutputStream(bytes);
      stream.writeObject(value);
      stream.flush();
      return BIN + Base64.getEncoder().encodeToString(bytes.toByteArray());
    } catch (IOException x) {
      throw SneakyThrows.propagate(x);
    } else if (value instanceof Serializable) {
      JavaSerializationHelper helper = new JavaSerializationHelper();
      return Pac4jSession.BIN + helper.serializeToBase64((Serializable) value);
    } else {
      throw new UnsupportedOperationException("Unsupported type: " + value.getClass().getName());
    }
  }

  private static String actionToStr(HttpAction action) {
    StringBuilder buffer = new StringBuilder();
    buffer.append(PAC4J).append(action.getCode());
    buffer.append(Pac4jSession.PAC4J).append(action.getCode());
    if (action instanceof WithContentAction) {
      buffer.append(":").append(((WithContentAction) action).getContent());
    } else if (action instanceof WithLocationAction) {
