=== Session

Sessions are accessible via:

* javadoc:Context[sessionOrNull]: Finds and returns an existing session (or returns `null`).
* javadoc:Context[session]: Finds an existing session or creates a new one if none exists.

Sessions are commonly used for authentication, storing user preferences, or tracking user state.

A session attribute **must be a String or a primitive**. The session API does not allow storing arbitrary Java objects or complex object graphs. It is intended as a simple, lightweight mechanism to store basic data.

Jooby provides the following javadoc:SessionStore[] implementations:

* **In-Memory Sessions:** Suitable for single-instance applications (or multi-instance if combined with a sticky-session proxy).
* **Signed Cookie Sessions:** Stateless sessions signed with a secret key.
* **JWT (JSON Web Token) Sessions:** Stateless, token-based sessions.

**Note:** Since Jooby 4.0.0, no session store is configured by default. Attempting to access a session at runtime without first configuring a store will result in an exception.

==== In-Memory Session

The in-memory session store saves session data directly in the server's RAM. It uses a cookie or HTTP header solely to track the session ID.

.In-Memory Session
[source,java,role="primary"]
----
{
  setSessionStore(SessionStore.memory(Cookie.session("myappid")));

  get("/", ctx -> {
    Session session = ctx.session();   // <1>
    session.put("foo", "bar");         // <2>
    
    return session.get("foo").value(); // <3>
  }); 
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
{
  sessionStore = SessionStore.memory(Cookie.session("myappid"))

  get("/") {
    val session = ctx.session()        // <1>
    session.put("foo", "bar")          // <2>
    
    session.get("foo").value()         // <3>
  }
}
----

<1> Finds an existing session or creates a new one.
<2> Sets a session attribute.
<3> Gets a session attribute.

By default, the session ID is retrieved from a request cookie. The default session cookie never expires and is set to `HttpOnly` under the root `/` path.

To customize the cookie details:

.In-Memory Session with Custom Cookie
[source,java,role="primary"]
----
{
  setSessionStore(SessionStore.memory(new Cookie("SESSION")));    // <1>

  get("/", ctx -> {
    Session session = ctx.session();
    session.put("foo", "bar");
    
    return session.get("foo").value();
  }); 
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
{
  sessionStore = SessionStore.memory(Cookie("SESSION"))           // <1>

  get("/") {
    val session = ctx.session()
    session.put("foo", "bar")
    
    session.get("foo").value()
  }
}
----

<1> Configures an in-memory session store using a custom cookie named `SESSION`.

Alternatively, you can use an HTTP header to transmit the session token/ID instead of a cookie:

.In-Memory Session with HTTP Header
[source,java,role="primary"]
----
{
  setSessionStore(SessionStore.memory(SessionToken.header("TOKEN")));    // <1>

  get("/", ctx -> {
    Session session = ctx.session();
    session.put("foo", "bar");
    
    return session.get("foo").value();
  }); 
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
{
  sessionStore = SessionStore.memory(SessionToken.header("TOKEN"))       // <1>

  get("/") {
    val session = ctx.session()
    session.put("foo", "bar")
    
    session.get("foo").value()
  }
}
----

<1> The Session Token/ID is read from the `TOKEN` HTTP header.

You can also combine both methods, telling Jooby to check the cookie first, and then fall back to the header:

.Mixed Tokens
[source,java,role="primary"]
----
{
  setSessionStore(SessionStore.memory(
      SessionToken.combine(SessionToken.cookie("SESSION"), SessionToken.header("TOKEN")) // <1>
  ));

  get("/", ctx -> {
    Session session = ctx.session();
    session.put("foo", "bar");
    
    return session.get("foo").value();
  }); 
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
{
  sessionStore = SessionStore.memory(
      SessionToken.combine(SessionToken.cookie("SESSION"), SessionToken.header("TOKEN")) // <1>
  )

  get("/") {
    val session = ctx.session()
    session.put("foo", "bar")
    
    session.get("foo").value()
  }
}
----

<1> The Session Token/ID is read from the `SESSION` cookie or the `TOKEN` header (in that order).

==== Signed Session

This is a **stateless** session store. The server does not keep any session state in memory. Instead, the entire session payload is serialized, cryptographically signed, and sent back and forth between the client and server on every request.

* Session data is retrieved/saved entirely from/into the HTTP Cookie or Header.
* Session data is signed using `HmacSHA256` to prevent tampering. The secret key must be at least 256 bits long (32 bytes).

Signing and verification are handled internally using javadoc:Cookie[sign, java.lang.String, java.lang.String] and javadoc:Cookie[unsign, java.lang.String, java.lang.String].

.Usage
[source,java,role="primary"]
----
{
  String secret = "super-secret-key-must-be-32-bytes";                        // <1>
  setSessionStore(SessionStore.signed(Cookie.session("myappid"), secret));    // <2>

  get("/", ctx -> {
    Session session = ctx.session();
    session.put("foo", "bar");
    
    return session.get("foo").value();
  }); 
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
{
  val secret = "super-secret-key-must-be-32-bytes"                           // <1>
  sessionStore = SessionStore.signed(Cookie.session("myappid"), secret)      // <2>

  get("/") {
    val session = ctx.session()
    session.put("foo", "bar")
    
    session.get("foo").value()
  }
}
----

<1> A secure, 32-byte secret key is required to sign the data.
<2> Creates a signed session store using a cookie and the secret key.

Just like the in-memory store, the signed session store also supports HTTP headers:

.Signed Session with HTTP Headers
[source,java,role="primary"]
----
{
  String secret = "super-secret-key-must-be-32-bytes";                           // <1>
  setSessionStore(SessionStore.signed(SessionToken.header("TOKEN"), secret));    // <2>

  get("/", ctx -> {
    Session session = ctx.session();
    session.put("foo", "bar");
    
    return session.get("foo").value();
  }); 
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
{
  val secret = "super-secret-key-must-be-32-bytes"                               // <1>
  sessionStore = SessionStore.signed(SessionToken.header("TOKEN"), secret)       // <2>

  get("/") {
    val session = ctx.session()
    session.put("foo", "bar")
    
    session.get("foo").value()
  }
}
----

==== Additional Stores

In addition to the built-in memory and signed stores, Jooby provides external module integrations:

* link:modules/caffeine[Caffeine]: High-performance in-memory session store using the Caffeine cache library.
* link:modules/jwt-session-store[JWT]: Stateless JSON Web Token session store.
* link:modules/redis#redis-http-session[Redis]: Distributed session store using Redis.
